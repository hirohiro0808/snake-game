<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="theme-color" content="#0b1020" />
  <title>五子棋：AI(5级) + 双人房间(P2P) - 优化版</title>
  <style>
    :root{
      --bg:#070a12;
      --card:rgba(255,255,255,.06);
      --card2:rgba(255,255,255,.09);
      --text:#e9eef8;
      --muted:rgba(233,238,248,.65);
      --line:rgba(255,255,255,.12);
      --accent:#5ad6ff;
      --danger:#ff5a7a;
      --ok:#3ddc97;
      --warning:#ffb84d;
      --grid-size: 15;
    }
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent;user-select:none}
    html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 20% 0%, #101a35 0%, #070a12 55%, #05070c 100%);color:var(--text);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial}
    
    .wrap{
      min-height:100vh;
      max-height:-webkit-fill-available;
      display:flex;
      flex-direction:column;
      padding:12px;
      gap:12px;
      padding-top:env(safe-area-inset-top,12px);
      padding-bottom:env(safe-area-inset-bottom,12px);
      overflow-y: auto;
    }
    
    /* 顶部区域 */
    .header{
      display:flex;
      flex-direction: column;
      gap:8px;
    }
    
    .title-row{
      display:flex;
      justify-content:space-between;
      align-items:center;
      flex-wrap:wrap;
      gap:10px;
    }
    
    .title-group{
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    
    .game-title{
      font-weight:900;
      font-size:22px;
      letter-spacing:.5px;
      background: linear-gradient(90deg, #5ad6ff 0%, #a78bfa 100%);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }
    
    .subtitle{
      font-size:13px;
      color:var(--muted);
    }
    
    /* 游戏状态标签 */
    .game-state{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    
    .state-tag{
      display:flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      border-radius:20px;
      background:rgba(90,214,255,.12);
      border:1px solid rgba(90,214,255,.2);
      font-size:12px;
      font-weight:500;
    }
    
    .state-tag .label{
      color:var(--muted);
    }
    
    .state-tag .value{
      color:var(--text);
      font-weight:600;
    }
    
    /* 游戏区域 */
    .game-container{
      display:grid;
      grid-template-columns:1fr;
      gap:12px;
    }
    
    @media(min-width:768px){
      .game-container{
        grid-template-columns:1.1fr .9fr;
      }
    }
    
    /* 棋盘区域 */
    .board-container{
      position:relative;
      background:linear-gradient(180deg,#0e1629,#0b1020);
      border-radius:16px;
      border:1px solid rgba(255,255,255,.08);
      overflow:hidden;
      box-shadow:0 12px 32px rgba(0,0,0,.4);
    }
    
    .board-wrapper{
      position:relative;
      width:100%;
      aspect-ratio:1/1;
      overflow:hidden;
    }
    
    #board{
      position:absolute;
      top:0;
      left:0;
      width:100%!important;
      height:100%!important;
      display:block;
    }
    
    /* 游戏控制栏 */
    .game-controls{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:12px;
      padding:14px;
      background:rgba(255,255,255,.04);
      border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
    }
    
    .controls-top{
      display:flex;
      justify-content:space-between;
      align-items:center;
      flex-wrap:wrap;
      gap:8px;
    }
    
    .game-info{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    
    .info-tag{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      border-radius:10px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.1);
      font-size:12px;
    }
    
    .controls-bottom{
      display:flex;
      gap:8px;
      justify-content:flex-end;
    }
    
    /* 按钮样式 */
    .btn{
      appearance:none;
      border:none;
      padding:10px 16px;
      border-radius:10px;
      font-weight:600;
      font-size:14px;
      cursor:pointer;
      transition:all 0.2s ease;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      min-height:44px;
      -webkit-tap-highlight-color:transparent;
    }
    
    .btn:active{
      transform:translateY(2px);
      opacity:0.9;
    }
    
    .btn.primary{
      background:linear-gradient(135deg, #5ad6ff, #2a9df4);
      color:white;
      box-shadow:0 4px 12px rgba(90,214,255,.3);
    }
    
    .btn.secondary{
      background:rgba(255,255,255,.1);
      color:var(--text);
      border:1px solid rgba(255,255,255,.15);
    }
    
    .btn.danger{
      background:linear-gradient(135deg, #ff5a7a, #e63956);
      color:white;
      box-shadow:0 4px 12px rgba(255,90,122,.3);
    }
    
    .btn.success{
      background:linear-gradient(135deg, #3ddc97, #2dbd7f);
      color:white;
      box-shadow:0 4px 12px rgba(61,220,151,.3);
    }
    
    .btn:disabled{
      opacity:0.5;
      cursor:not-allowed;
      transform:none!important;
    }
    
    /* 右侧面板 */
    .side-panel{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    
    .panel-card{
      background:rgba(255,255,255,.04);
      border-radius:14px;
      padding:16px;
      border:1px solid rgba(255,255,255,.08);
      backdrop-filter:blur(10px);
    }
    
    .panel-title{
      font-size:16px;
      font-weight:600;
      margin-bottom:12px;
      color:var(--text);
    }
    
    /* 模式选择 */
    .mode-selector{
      display:flex;
      border-radius:10px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.15);
      margin-bottom:16px;
    }
    
    .mode-btn{
      flex:1;
      padding:10px;
      border:none;
      background:transparent;
      color:var(--muted);
      font-weight:600;
      font-size:13px;
      cursor:pointer;
      transition:all 0.2s;
      text-align:center;
    }
    
    .mode-btn.active{
      background:rgba(90,214,255,.2);
      color:var(--text);
    }
    
    /* AI设置 */
    .ai-settings{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    
    .ai-level-container{
      display:flex;
      justify-content:space-between;
      align-items:center;
      background:rgba(0,0,0,.2);
      padding:12px;
      border-radius:10px;
    }
    
    .level-controls{
      display:flex;
      gap:6px;
    }
    
    .level-btn{
      width:36px;
      height:36px;
      border-radius:8px;
      border:none;
      background:rgba(255,255,255,.1);
      color:var(--text);
      font-size:18px;
      font-weight:600;
      cursor:pointer;
    }
    
    .level-display{
      font-size:18px;
      font-weight:600;
      color:#5ad6ff;
      min-width:60px;
      text-align:center;
    }
    
    /* 联机面板 */
    .connection-status{
      display:flex;
      align-items:center;
      gap:8px;
      padding:10px;
      border-radius:8px;
      margin-bottom:12px;
      font-size:13px;
    }
    
    .status-indicator{
      width:8px;
      height:8px;
      border-radius:50%;
      background:var(--muted);
    }
    
    .status-indicator.connected{
      background:#3ddc97;
      animation:pulse 2s infinite;
    }
    
    @keyframes pulse{
      0%,100%{opacity:1;}
      50%{opacity:0.5;}
    }
    
    .connection-controls{
      display:flex;
      gap:8px;
      margin-bottom:16px;
    }
    
    .connection-code{
      font-family:monospace;
      background:rgba(0,0,0,.3);
      padding:12px;
      border-radius:8px;
      text-align:center;
      font-size:18px;
      letter-spacing:2px;
      margin:12px 0;
      border:1px solid rgba(255,255,255,.1);
      word-break:break-all;
    }
    
    .textarea{
      width:100%;
      min-height:80px;
      padding:10px;
      border-radius:8px;
      background:rgba(0,0,0,.3);
      border:1px solid rgba(255,255,255,.15);
      color:var(--text);
      font-family:monospace;
      font-size:12px;
      resize:vertical;
    }
    
    /* 游戏结束遮罩 */
    .game-overlay{
      position:absolute;
      top:0;
      left:0;
      width:100%;
      height:100%;
      background:rgba(0,0,0,.85);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      z-index:100;
      opacity:0;
      pointer-events:none;
      transition:opacity 0.3s;
    }
    
    .game-overlay.active{
      opacity:1;
      pointer-events:all;
    }
    
    .game-overlay-content{
      background:linear-gradient(135deg, #0e1629, #0b1020);
      padding:30px;
      border-radius:20px;
      text-align:center;
      border:1px solid rgba(90,214,255,.3);
      box-shadow:0 20px 40px rgba(0,0,0,.5);
      max-width:90%;
    }
    
    .result-title{
      font-size:28px;
      font-weight:800;
      margin-bottom:10px;
      background:linear-gradient(90deg, #ff5a7a, #ffb84d);
      -webkit-background-clip:text;
      background-clip:text;
      color:transparent;
    }
    
    .result-subtitle{
      font-size:18px;
      color:var(--muted);
      margin-bottom:20px;
    }
    
    /* 提示信息 */
    .hint{
      font-size:12px;
      color:var(--muted);
      line-height:1.5;
      margin-top:8px;
    }
    
    /* 移动端优化 */
    @media(max-width:480px){
      .btn{
        padding:10px 12px;
        font-size:13px;
      }
      
      .panel-card{
        padding:12px;
      }
      
      .game-overlay-content{
        padding:20px;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- 顶部标题区域 -->
    <div class="header">
      <div class="title-row">
        <div class="title-group">
          <div class="game-title">五子棋</div>
          <div class="subtitle">AI对战(1~5级) / 本地双人 / P2P联机对战</div>
        </div>
        <div class="game-state">
          <div class="state-tag">
            <span class="label">先手:</span>
            <span class="value" id="firstPlayerText">黑方</span>
          </div>
          <div class="state-tag">
            <span class="label">规则:</span>
            <span class="value">连五即胜</span>
          </div>
        </div>
      </div>
    </div>

    <!-- 游戏主区域 -->
    <div class="game-container">
      <!-- 左侧: 棋盘 -->
      <div class="board-container">
        <div class="board-wrapper">
          <canvas id="board"></canvas>
          
          <!-- 游戏结束遮罩 -->
          <div class="game-overlay" id="gameOverlay">
            <div class="game-overlay-content">
              <div class="result-title" id="resultTitle">游戏结束</div>
              <div class="result-subtitle" id="resultSubtitle">黑方获胜!</div>
              <div class="controls-bottom" style="margin-top:20px;">
                <button class="btn primary" id="restartBtn">重新开始</button>
                <button class="btn secondary" id="continueBtn">继续游戏</button>
              </div>
            </div>
          </div>
        </div>
        
        <!-- 游戏控制栏 -->
        <div class="game-controls">
          <div class="controls-top">
            <div class="game-info">
              <div class="info-tag">
                <span class="label">当前回合:</span>
                <span class="value" id="currentTurnText">黑方</span>
              </div>
              <div class="info-tag">
                <span class="label">游戏模式:</span>
                <span class="value" id="gameModeText">AI对战</span>
              </div>
              <div class="info-tag">
                <span class="label">游戏状态:</span>
                <span class="value" id="gameStatusText">进行中</span>
              </div>
            </div>
          </div>
          
          <div class="controls-bottom">
            <button class="btn primary" id="newGameBtn">
              <span>新游戏</span>
            </button>
            <button class="btn secondary" id="undoBtn">
              <span>悔棋</span>
            </button>
            <button class="btn secondary" id="swapBtn">
              <span>交换先手</span>
            </button>
            <button class="btn danger" id="resetBtn">
              <span>重置</span>
            </button>
          </div>
        </div>
      </div>

      <!-- 右侧: 设置面板 -->
      <div class="side-panel">
        <!-- 模式选择 -->
        <div class="panel-card">
          <div class="panel-title">游戏设置</div>
          
          <div class="mode-selector">
            <button class="mode-btn active" data-mode="ai" id="modeAI">AI对战</button>
            <button class="mode-btn" data-mode="local" id="modeLocal">本地双人</button>
            <button class="mode-btn" data-mode="online" id="modeOnline">联机对战</button>
          </div>
          
          <!-- AI设置 -->
          <div class="ai-settings" id="aiSettings">
            <div class="panel-title" style="font-size:14px;margin-bottom:8px;">AI难度设置</div>
            <div class="ai-level-container">
              <div>AI等级:</div>
              <div class="level-display" id="aiLevelDisplay">3</div>
              <div class="level-controls">
                <button class="level-btn" id="aiLevelDown">-</button>
                <button class="level-btn" id="aiLevelUp">+</button>
              </div>
            </div>
            <div class="hint">
              等级越高，AI思考越深，计算越精确。等级1最简单，等级5最难。
            </div>
          </div>
          
          <!-- 联机设置 -->
          <div class="ai-settings" id="onlineSettings" style="display:none;">
            <div class="connection-status">
              <div class="status-indicator" id="connectionIndicator"></div>
              <span id="connectionStatusText">未连接</span>
            </div>
            
            <div class="connection-controls">
              <button class="btn success" id="hostBtn" style="flex:1;">创建房间</button>
              <button class="btn secondary" id="joinBtn" style="flex:1;">加入房间</button>
              <button class="btn danger" id="disconnectBtn" disabled style="flex:1;">断开连接</button>
            </div>
            
            <div id="roomCodeSection" style="display:none;">
              <div style="font-size:13px;margin-bottom:6px;">房间代码:</div>
              <div class="connection-code" id="roomCodeDisplay"></div>
              <div class="hint">将此代码分享给好友以加入游戏</div>
            </div>
            
            <div id="joinSection" style="display:none;margin-top:12px;">
              <div style="font-size:13px;margin-bottom:6px;">输入房间代码:</div>
              <input type="text" class="textarea" id="roomCodeInput" placeholder="请输入房间代码" style="min-height:40px;">
              <button class="btn success" id="connectBtn" style="margin-top:8px;width:100%;">连接</button>
            </div>
          </div>
        </div>
        
        <!-- 游戏说明 -->
        <div class="panel-card">
          <div class="panel-title">游戏说明</div>
          <div class="hint">
            <strong>基本规则:</strong> 黑方先手，在棋盘上横向、纵向或斜向连成五子即获胜。<br><br>
            <strong>AI对战:</strong> 与不同难度的电脑AI对战，可随时交换先后手。<br><br>
            <strong>本地双人:</strong> 在同一设备上两人轮流对战。<br><br>
            <strong>联机对战:</strong> 通过房间代码与好友实时对战。
          </div>
        </div>
        
        <!-- 游戏统计 -->
        <div class="panel-card">
          <div class="panel-title">游戏统计</div>
          <div style="display:flex;justify-content:space-between;margin-bottom:8px;">
            <span>黑方胜利:</span>
            <span id="blackWins">0</span>
          </div>
          <div style="display:flex;justify-content:space-between;margin-bottom:8px;">
            <span>白方胜利:</span>
            <span id="whiteWins">0</span>
          </div>
          <div style="display:flex;justify-content:space-between;">
            <span>平局:</span>
            <span id="draws">0</span>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  'use strict';
  
  // ==================== 常量定义 ====================
  const BOARD_SIZE = 15;
  const EMPTY = 0, BLACK = 1, WHITE = 2;
  const MODES = { AI: 'ai', LOCAL: 'local', ONLINE: 'online' };
  
  // ==================== DOM元素引用 ====================
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  
  // 信息显示元素
  const currentTurnText = document.getElementById('currentTurnText');
  const gameModeText = document.getElementById('gameModeText');
  const gameStatusText = document.getElementById('gameStatusText');
  const firstPlayerText = document.getElementById('firstPlayerText');
  
  // 按钮元素
  const newGameBtn = document.getElementById('newGameBtn');
  const undoBtn = document.getElementById('undoBtn');
  const swapBtn = document.getElementById('swapBtn');
  const resetBtn = document.getElementById('resetBtn');
  const restartBtn = document.getElementById('restartBtn');
  const continueBtn = document.getElementById('continueBtn');
  
  // 模式选择
  const modeAI = document.getElementById('modeAI');
  const modeLocal = document.getElementById('modeLocal');
  const modeOnline = document.getElementById('modeOnline');
  const aiSettings = document.getElementById('aiSettings');
  const onlineSettings = document.getElementById('onlineSettings');
  
  // AI设置
  const aiLevelDisplay = document.getElementById('aiLevelDisplay');
  const aiLevelDown = document.getElementById('aiLevelDown');
  const aiLevelUp = document.getElementById('aiLevelUp');
  
  // 联机设置
  const connectionIndicator = document.getElementById('connectionIndicator');
  const connectionStatusText = document.getElementById('connectionStatusText');
  const hostBtn = document.getElementById('hostBtn');
  const joinBtn = document.getElementById('joinBtn');
  const disconnectBtn = document.getElementById('disconnectBtn');
  const roomCodeSection = document.getElementById('roomCodeSection');
  const joinSection = document.getElementById('joinSection');
  const roomCodeDisplay = document.getElementById('roomCodeDisplay');
  const roomCodeInput = document.getElementById('roomCodeInput');
  const connectBtn = document.getElementById('connectBtn');
  
  // 游戏结束遮罩
  const gameOverlay = document.getElementById('gameOverlay');
  const resultTitle = document.getElementById('resultTitle');
  const resultSubtitle = document.getElementById('resultSubtitle');
  
  // 统计数据
  const blackWinsEl = document.getElementById('blackWins');
  const whiteWinsEl = document.getElementById('whiteWins');
  const drawsEl = document.getElementById('draws');
  
  // ==================== 游戏状态变量 ====================
  let board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(EMPTY));
  let moves = []; // 记录所有走法 {x, y, player}
  let currentPlayer = BLACK; // 当前回合玩家
  let winner = EMPTY; // 胜利者
  let gameMode = MODES.AI; // 当前游戏模式
  let aiLevel = 3; // AI等级 (1-5)
  let isGameActive = false; // 游戏是否进行中
  let isAiThinking = false; // AI是否正在思考
  
  // AI对战相关
  let humanPlayer = BLACK; // 人类玩家颜色
  let aiPlayer = WHITE; // AI玩家颜色
  
  // 联机对战相关
  let isHost = false; // 是否是房主
  let roomCode = ''; // 房间代码
  let connection = null; // WebRTC连接
  
  // 统计数据
  let stats = {
    blackWins: 0,
    whiteWins: 0,
    draws: 0
  };
  
  // ==================== 画布初始化 ====================
  function initCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.parentElement.getBoundingClientRect();
    const size = Math.min(rect.width, rect.height);
    
    // 设置画布尺寸
    canvas.width = size * dpr;
    canvas.height = size * dpr;
    canvas.style.width = `${size}px`;
    canvas.style.height = `${size}px`;
    
    // 缩放上下文
    ctx.scale(dpr, dpr);
    
    drawBoard();
  }
  
  // ==================== 棋盘绘制 ====================
  function drawBoard() {
    const size = canvas.width / (window.devicePixelRatio || 1);
    const cellSize = size / (BOARD_SIZE + 1);
    const padding = cellSize * 0.5;
    
    // 清空画布
    ctx.clearRect(0, 0, size, size);
    
    // 绘制棋盘背景
    ctx.fillStyle = '#0b1020';
    ctx.fillRect(0, 0, size, size);
    
    // 绘制网格
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
    ctx.lineWidth = 1;
    
    for (let i = 0; i < BOARD_SIZE; i++) {
      const pos = padding + i * cellSize;
      
      // 垂直线
      ctx.beginPath();
      ctx.moveTo(pos, padding);
      ctx.lineTo(pos, size - padding);
      ctx.stroke();
      
      // 水平线
      ctx.beginPath();
      ctx.moveTo(padding, pos);
      ctx.lineTo(size - padding, pos);
      ctx.stroke();
    }
    
    // 绘制星位
    const starPoints = [
      [3, 3], [3, 11], [11, 3], [11, 11],
      [7, 7] // 天元
    ];
    
    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
    starPoints.forEach(([x, y]) => {
      const cx = padding + x * cellSize;
      const cy = padding + y * cellSize;
      ctx.beginPath();
      ctx.arc(cx, cy, cellSize * 0.1, 0, Math.PI * 2);
      ctx.fill();
    });
    
    // 绘制棋子
    for (let y = 0; y < BOARD_SIZE; y++) {
      for (let x = 0; x < BOARD_SIZE; x++) {
        if (board[y][x] !== EMPTY) {
          drawPiece(x, y, board[y][x]);
        }
      }
    }
    
    // 高亮显示最后一步
    if (moves.length > 0) {
      const lastMove = moves[moves.length - 1];
      drawLastMoveHighlight(lastMove.x, lastMove.y);
    }
  }
  
  function drawPiece(x, y, player) {
    const size = canvas.width / (window.devicePixelRatio || 1);
    const cellSize = size / (BOARD_SIZE + 1);
    const padding = cellSize * 0.5;
    const radius = cellSize * 0.4;
    
    const cx = padding + x * cellSize;
    const cy = padding + y * cellSize;
    
    // 棋子阴影
    ctx.beginPath();
    ctx.arc(cx + 2, cy + 2, radius, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.fill();
    
    // 棋子渐变
    const gradient = ctx.createRadialGradient(
      cx - radius * 0.3, cy - radius * 0.3, 1,
      cx, cy, radius
    );
    
    if (player === BLACK) {
      gradient.addColorStop(0, '#666');
      gradient.addColorStop(1, '#000');
    } else {
      gradient.addColorStop(0, '#fff');
      gradient.addColorStop(1, '#ddd');
    }
    
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
    ctx.fillStyle = gradient;
    ctx.fill();
    
    // 棋子边框
    ctx.strokeStyle = player === BLACK ? '#333' : '#bbb';
    ctx.lineWidth = 1;
    ctx.stroke();
  }
  
  function drawLastMoveHighlight(x, y) {
    const size = canvas.width / (window.devicePixelRatio || 1);
    const cellSize = size / (BOARD_SIZE + 1);
    const padding = cellSize * 0.5;
    const radius = cellSize * 0.15;
    
    const cx = padding + x * cellSize;
    const cy = padding + y * cellSize;
    
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
    ctx.fillStyle = '#ff5a7a';
    ctx.fill();
  }
  
  // ==================== 游戏逻辑 ====================
  function startNewGame() {
    // 重置棋盘
    board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(EMPTY));
    moves = [];
    winner = EMPTY;
    isGameActive = true;
    
    // 设置先手玩家
    if (gameMode === MODES.AI) {
      currentPlayer = humanPlayer;
    } else {
      currentPlayer = BLACK;
    }
    
    // 隐藏游戏结束遮罩
    gameOverlay.classList.remove('active');
    
    updateUI();
    drawBoard();
    
    // 如果AI先手，则AI走第一步
    if (gameMode === MODES.AI && currentPlayer === aiPlayer) {
      setTimeout(makeAiMove, 500);
    }
  }
  
  function placePiece(x, y, player) {
    if (!isGameActive || winner !== EMPTY) return false;
    if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE) return false;
    if (board[y][x] !== EMPTY) return false;
    
    // 放置棋子
    board[y][x] = player;
    moves.push({ x, y, player });
    
    // 检查是否获胜
    if (checkWin(x, y, player)) {
      winner = player;
      isGameActive = false;
      showGameResult(player === BLACK ? '黑方获胜!' : '白方获胜!');
      updateStats(player);
    } else if (moves.length === BOARD_SIZE * BOARD_SIZE) {
      // 平局
      winner = EMPTY;
      isGameActive = false;
      showGameResult('平局!');
      stats.draws++;
      updateStatsDisplay();
    } else {
      // 切换玩家
      currentPlayer = player === BLACK ? WHITE : BLACK;
    }
    
    drawBoard();
    updateUI();
    
    return true;
  }
  
  function checkWin(x, y, player) {
    // 检查方向: 水平、垂直、对角线
    const directions = [
      [1, 0],  // 水平
      [0, 1],  // 垂直
      [1, 1],  // 对角线 \
      [1, -1]  // 对角线 /
    ];
    
    for (const [dx, dy] of directions) {
      let count = 1;
      
      // 正向检查
      for (let i = 1; i <= 4; i++) {
        const nx = x + dx * i;
        const ny = y + dy * i;
        if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
        if (board[ny][nx] !== player) break;
        count++;
      }
      
      // 反向检查
      for (let i = 1; i <= 4; i++) {
        const nx = x - dx * i;
        const ny = y - dy * i;
        if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
        if (board[ny][nx] !== player) break;
        count++;
      }
      
      if (count >= 5) return true;
    }
    
    return false;
  }
  
  function undoMove() {
    if (!isGameActive || moves.length === 0) return;
    
    // 如果是AI模式且轮到AI，需要悔两步
    if (gameMode === MODES.AI && currentPlayer === aiPlayer && moves.length >= 2) {
      // 移除AI的最后一步
      const lastMove = moves.pop();
      board[lastMove.y][lastMove.x] = EMPTY;
      
      // 移除玩家的最后一步
      const secondLastMove = moves.pop();
      board[secondLastMove.y][secondLastMove.x] = EMPTY;
      
      currentPlayer = humanPlayer;
    } else {
      // 移除最后一步
      const lastMove = moves.pop();
      board[lastMove.y][lastMove.x] = EMPTY;
      currentPlayer = lastMove.player === BLACK ? WHITE : BLACK;
    }
    
    winner = EMPTY;
    drawBoard();
    updateUI();
  }
  
  function swapPlayers() {
    if (gameMode !== MODES.AI) return;
    
    humanPlayer = humanPlayer === BLACK ? WHITE : BLACK;
    aiPlayer = aiPlayer === BLACK ? WHITE : BLACK;
    
    // 如果游戏进行中，重新开始
    if (isGameActive) {
      startNewGame();
    } else {
      updateUI();
    }
  }
  
  function showGameResult(result) {
    resultTitle.textContent = '游戏结束';
    resultSubtitle.textContent = result;
    gameOverlay.classList.add('active');
  }
  
  // ==================== AI逻辑 ====================
  async function makeAiMove() {
    if (!isGameActive || winner !== EMPTY || currentPlayer !== aiPlayer || isAiThinking) {
      return;
    }
    
    isAiThinking = true;
    gameStatusText.textContent = 'AI思考中...';
    
    // 使用setTimeout让UI有机会更新
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // 获取最佳走法
    const bestMove = getBestMove();
    
    if (bestMove) {
      // 模拟思考时间
      await new Promise(resolve => setTimeout(resolve, 300));
      
      placePiece(bestMove.x, bestMove.y, aiPlayer);
    }
    
    isAiThinking = false;
    updateUI();
  }
  
  function getBestMove() {
    const depth = aiLevel; // 搜索深度与AI等级相关
    const candidates = getCandidateMoves();
    
    // 如果没有候选位置，返回null
    if (candidates.length === 0) return null;
    
    let bestScore = -Infinity;
    let bestMove = candidates[0];
    
    // 简单的启发式搜索
    for (const move of candidates) {
      // 尝试走这一步
      board[move.y][move.x] = aiPlayer;
      
      // 计算分数
      let score = evaluatePosition(move.x, move.y, aiPlayer);
      
      // 如果是必胜步，直接返回
      if (checkWin(move.x, move.y, aiPlayer)) {
        board[move.y][move.x] = EMPTY;
        return move;
      }
      
      // 如果对方有必胜步，优先防守
      board[move.y][move.x] = humanPlayer;
      if (checkWin(move.x, move.y, humanPlayer)) {
        board[move.y][move.x] = EMPTY;
        score += 10000; // 防守得分
        return { x: move.x, y: move.y };
      }
      board[move.y][move.x] = EMPTY;
      
      // 根据AI等级调整搜索
      if (aiLevel >= 3) {
        // 中级以上AI会考虑更多
        score += evaluateBoard(aiPlayer) - evaluateBoard(humanPlayer);
      }
      
      if (aiLevel >= 4) {
        // 高级AI会进行简单的前瞻
        score += lookAhead(move.x, move.y, aiPlayer, depth - 1);
      }
      
      // 更新最佳走法
      if (score > bestScore) {
        bestScore = score;
        bestMove = move;
      }
    }
    
    return bestMove;
  }
  
  function getCandidateMoves() {
    const candidates = [];
    
    // 如果棋盘为空，返回中心点
    if (moves.length === 0) {
      return [{ x: Math.floor(BOARD_SIZE / 2), y: Math.floor(BOARD_SIZE / 2) }];
    }
    
    // 收集所有空位，但只考虑已有棋子附近的空位
    for (let y = 0; y < BOARD_SIZE; y++) {
      for (let x = 0; x < BOARD_SIZE; x++) {
        if (board[y][x] === EMPTY) {
          // 检查附近是否有棋子
          if (hasNeighbor(x, y, 2)) {
            candidates.push({ x, y, score: evaluateMove(x, y) });
          }
        }
      }
    }
    
    // 按分数排序，返回前N个候选
    candidates.sort((a, b) => b.score - a.score);
    const limit = Math.min(candidates.length, aiLevel * 6); // 根据AI等级限制候选数量
    return candidates.slice(0, limit).map(m => ({ x: m.x, y: m.y }));
  }
  
  function hasNeighbor(x, y, radius) {
    for (let dy = -radius; dy <= radius; dy++) {
      for (let dx = -radius; dx <= radius; dx++) {
        const nx = x + dx;
        const ny = y + dy;
        
        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
          if (board[ny][nx] !== EMPTY) {
            return true;
          }
        }
      }
    }
    return false;
  }
  
  function evaluateMove(x, y) {
    let score = 0;
    
    // 位置价值：中心位置更有价值
    const center = Math.floor(BOARD_SIZE / 2);
    const distFromCenter = Math.abs(x - center) + Math.abs(y - center);
    score += (BOARD_SIZE - distFromCenter) * 10;
    
    // 模式匹配得分
    score += evaluatePosition(x, y, aiPlayer) * 2;
    score += evaluatePosition(x, y, humanPlayer) * 1.5;
    
    return score;
  }
  
  function evaluatePosition(x, y, player) {
    const directions = [
      [1, 0], [0, 1], [1, 1], [1, -1]
    ];
    
    let totalScore = 0;
    
    for (const [dx, dy] of directions) {
      let pattern = '';
      
      // 收集5个位置（包括当前位置）
      for (let i = -4; i <= 4; i++) {
        const nx = x + dx * i;
        const ny = y + dy * i;
        
        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
          if (board[ny][nx] === player) {
            pattern += '1';
          } else if (board[ny][nx] === EMPTY) {
            pattern += '0';
          } else {
            pattern += '2'; // 对方棋子
          }
        } else {
          pattern += 'x'; // 边界外
        }
      }
      
      // 模式匹配评分
      totalScore += evaluatePattern(pattern, player);
    }
    
    return totalScore;
  }
  
  function evaluatePattern(pattern, player) {
    // 简单的模式匹配
    const patterns = {
      '11111': 1000000, // 连五
      '011110': 100000,  // 活四
      '011112': 10000,   // 冲四
      '01110': 5000,     // 活三
      '01112': 1000,     // 眠三
      '0110': 500,       // 活二
      '0112': 100,       // 眠二
    };
    
    let score = 0;
    
    for (const [key, value] of Object.entries(patterns)) {
      if (pattern.includes(key)) {
        score += value;
      }
    }
    
    return score;
  }
  
  function evaluateBoard(player) {
    let score = 0;
    
    // 简单的棋盘评估
    for (let y = 0; y < BOARD_SIZE; y++) {
      for (let x = 0; x < BOARD_SIZE; x++) {
        if (board[y][x] === player) {
          score += evaluatePosition(x, y, player);
        }
      }
    }
    
    return score;
  }
  
  function lookAhead(x, y, player, depth) {
    if (depth <= 0) return 0;
    
    // 尝试走这一步
    board[y][x] = player;
    
    // 检查是否获胜
    if (checkWin(x, y, player)) {
      board[y][x] = EMPTY;
      return 10000;
    }
    
    // 评估这个位置
    let score = evaluatePosition(x, y, player);
    
    // 递归搜索
    const opponent = player === BLACK ? WHITE : BLACK;
    const candidates = getCandidateMoves();
    
    if (candidates.length > 0) {
      const bestOpponentMove = candidates[0];
      score -= lookAhead(bestOpponentMove.x, bestOpponentMove.y, opponent, depth - 1) * 0.8;
    }
    
    // 撤销这一步
    board[y][x] = EMPTY;
    
    return score;
  }
  
  // ==================== 联机功能 ====================
  function generateRoomCode() {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // 移除容易混淆的字符
    let code = '';
    for (let i = 0; i < 6; i++) {
      code += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return code;
  }
  
  function showToast(message, type = 'info') {
    // 简单的toast实现
    const toast = document.createElement('div');
    toast.textContent = message;
    toast.style.cssText = `
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: ${type === 'error' ? '#ff5a7a' : type === 'success' ? '#3ddc97' : 'rgba(90,214,255,0.9)'};
      color: white;
      padding: 10px 16px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      animation: fadeInOut 3s ease;
    `;
    
    document.body.appendChild(toast);
    
    setTimeout(() => {
      toast.style.opacity = '0';
      toast.style.transition = 'opacity 0.3s';
      setTimeout(() => toast.remove(), 300);
    }, 2700);
  }
  
  // ==================== UI更新 ====================
  function updateUI() {
    // 更新回合显示
    currentTurnText.textContent = currentPlayer === BLACK ? '黑方' : '白方';
    currentTurnText.style.color = currentPlayer === BLACK ? '#fff' : '#ddd';
    
    // 更新游戏状态
    if (!isGameActive) {
      gameStatusText.textContent = winner === EMPTY ? '等待开始' : '已结束';
    } else {
      gameStatusText.textContent = isAiThinking ? 'AI思考中...' : '进行中';
    }
    
    // 更新游戏模式显示
    gameModeText.textContent = 
      gameMode === MODES.AI ? 'AI对战' : 
      gameMode === MODES.LOCAL ? '本地双人' : '联机对战';
    
    // 更新先手显示
    if (gameMode === MODES.AI) {
      firstPlayerText.textContent = humanPlayer === BLACK ? '黑方(你)' : '白方(AI)';
    } else {
      firstPlayerText.textContent = '黑方';
    }
    
    // 更新AI等级显示
    aiLevelDisplay.textContent = aiLevel;
    
    // 更新联机状态
    updateConnectionStatus();
    
    // 更新统计数据
    updateStatsDisplay();
  }
  
  function updateStats(winner) {
    if (winner === BLACK) {
      stats.blackWins++;
    } else if (winner === WHITE) {
      stats.whiteWins++;
    } else {
      stats.draws++;
    }
  }
  
  function updateStatsDisplay() {
    blackWinsEl.textContent = stats.blackWins;
    whiteWinsEl.textContent = stats.whiteWins;
    drawsEl.textContent = stats.draws;
  }
  
  function updateConnectionStatus() {
    if (gameMode !== MODES.ONLINE) {
      connectionIndicator.style.background = 'var(--muted)';
      connectionStatusText.textContent = '未连接';
      return;
    }
    
    // 这里可以添加实际的连接状态检查
    if (connection) {
      connectionIndicator.style.background = '#3ddc97';
      connectionIndicator.classList.add('connected');
      connectionStatusText.textContent = '已连接';
    } else {
      connectionIndicator.style.background = '#ff5a7a';
      connectionIndicator.classList.remove('connected');
      connectionStatusText.textContent = '未连接';
    }
  }
  
  // ==================== 事件处理 ====================
  function handleCanvasClick(event) {
    if (!isGameActive || winner !== EMPTY) return;
    
    // 获取点击位置
    const rect = canvas.getBoundingClientRect();
    const size = canvas.width / (window.devicePixelRatio || 1);
    const cellSize = size / (BOARD_SIZE + 1);
    const padding = cellSize * 0.5;
    
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    
    // 计算棋盘坐标
    const boardX = Math.round((x - padding) / cellSize);
    const boardY = Math.round((y - padding) / cellSize);
    
    // 检查坐标是否有效
    if (boardX >= 0 && boardX < BOARD_SIZE && boardY >= 0 && boardY < BOARD_SIZE) {
      // 检查是否可以落子
      if (gameMode === MODES.AI) {
        // AI模式：只有人类玩家可以落子
        if (currentPlayer === humanPlayer) {
          if (placePiece(boardX, boardY, humanPlayer)) {
            // AI回应
            setTimeout(makeAiMove, 300);
          }
        }
      } else if (gameMode === MODES.LOCAL) {
        // 本地双人模式：双方都可以落子
        placePiece(boardX, boardY, currentPlayer);
      } else if (gameMode === MODES.ONLINE) {
        // 联机模式：只有当前回合的玩家可以落子
        // 这里需要添加联机逻辑
        placePiece(boardX, boardY, currentPlayer);
        showToast('联机功能正在开发中', 'info');
      }
    }
  }
  
  // ==================== 事件监听器 ====================
  window.addEventListener('resize', initCanvas);
  
  canvas.addEventListener('click', handleCanvasClick);
  
  // 新游戏按钮
  newGameBtn.addEventListener('click', () => {
    startNewGame();
    showToast('新游戏已开始', 'success');
  });
  
  // 悔棋按钮
  undoBtn.addEventListener('click', () => {
    undoMove();
    showToast('已悔棋', 'info');
  });
  
  // 交换先手按钮
  swapBtn.addEventListener('click', () => {
    swapPlayers();
    showToast('已交换先手', 'success');
  });
  
  // 重置按钮
  resetBtn.addEventListener('click', () => {
    if (confirm('确定要重置游戏吗？')) {
      startNewGame();
      showToast('游戏已重置', 'info');
    }
  });
  
  // 重新开始按钮
  restartBtn.addEventListener('click', () => {
    gameOverlay.classList.remove('active');
    startNewGame();
  });
  
  // 继续游戏按钮
  continueBtn.addEventListener('click', () => {
    gameOverlay.classList.remove('active');
  });
  
  // 模式选择
  [modeAI, modeLocal, modeOnline].forEach(btn => {
    btn.addEventListener('click', () => {
      // 更新按钮状态
      [modeAI, modeLocal, modeOnline].forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // 更新游戏模式
      gameMode = btn.dataset.mode;
      
      // 显示/隐藏设置面板
      if (gameMode === MODES.AI) {
        aiSettings.style.display = 'block';
        onlineSettings.style.display = 'none';
      } else if (gameMode === MODES.ONLINE) {
        aiSettings.style.display = 'none';
        onlineSettings.style.display = 'block';
      } else {
        aiSettings.style.display = 'none';
        onlineSettings.style.display = 'none';
      }
      
      // 重置游戏
      startNewGame();
      updateUI();
    });
  });
  
  // AI等级控制
  aiLevelDown.addEventListener('click', () => {
    aiLevel = Math.max(1, aiLevel - 1);
    aiLevelDisplay.textContent = aiLevel;
    showToast(`AI等级已调整为: ${aiLevel}`, 'info');
  });
  
  aiLevelUp.addEventListener('click', () => {
    aiLevel = Math.min(5, aiLevel + 1);
    aiLevelDisplay.textContent = aiLevel;
    showToast(`AI等级已调整为: ${aiLevel}`, 'info');
  });
  
  // 联机功能按钮
  hostBtn.addEventListener('click', () => {
    roomCode = generateRoomCode();
    isHost = true;
    
    roomCodeSection.style.display = 'block';
    joinSection.style.display = 'none';
    roomCodeDisplay.textContent = roomCode;
    
    showToast(`房间已创建，代码: ${roomCode}`, 'success');
  });
  
  joinBtn.addEventListener('click', () => {
    roomCodeSection.style.display = 'none';
    joinSection.style.display = 'block';
  });
  
  connectBtn.addEventListener('click', () => {
    const code = roomCodeInput.value.trim().toUpperCase();
    if (code.length === 6) {
      roomCode = code;
      isHost = false;
      
      // 模拟连接成功
      connection = { connected: true };
      updateUI();
      showToast(`正在连接房间: ${code}`, 'info');
      
      // 这里应该添加实际的WebRTC连接逻辑
      setTimeout(() => {
        showToast('已连接到房间，等待房主开始游戏', 'success');
      }, 1000);
    } else {
      showToast('请输入有效的6位房间代码', 'error');
    }
  });
  
  disconnectBtn.addEventListener('click', () => {
    connection = null;
    roomCodeSection.style.display = 'none';
    joinSection.style.display = 'none';
    updateUI();
    showToast('已断开连接', 'info');
  });
  
  // ==================== 初始化 ====================
  function init() {
    // 加载统计数据
    const savedStats = localStorage.getItem('gomoku_stats');
    if (savedStats) {
      stats = JSON.parse(savedStats);
    }
    
    // 初始化画布
    initCanvas();
    
    // 初始化游戏
    startNewGame();
    
    // 初始化UI
    updateUI();
    
    // 保存统计数据到localStorage
    window.addEventListener('beforeunload', () => {
      localStorage.setItem('gomoku_stats', JSON.stringify(stats));
    });
  }
  
  // 启动游戏
  init();
})();
</script>
</body>
</html>
